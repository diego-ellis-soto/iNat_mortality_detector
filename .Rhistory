coords = c("lon","lat"), crs = 4326
)
iso_list <- list()
for (mode in input$transport_modes) {
for (t in input$iso_times) {
iso <- tryCatch({
mb_isochrone(location_sf, time = as.numeric(t), profile = mode,
access_token = mapbox_token)
}, error = function(e) {
showNotification(paste("Isochrone error:", mode, t, e$message), type = "error")
NULL
})
if (!is.null(iso)) {
iso$mode <- mode
iso$time <- t
iso_list <- append(iso_list, list(iso))
}
}
}
if (length(iso_list) == 0) {
showNotification("No isochrones generated.", type = "warning")
return(NULL)
}
all_iso <- do.call(rbind, iso_list) %>% st_transform(4326)
all_iso
})
# ------------------------------------------------
# Plot Isochrones + NDVI
# ------------------------------------------------
observeEvent(isochrones_data(), {
iso_data <- isochrones_data()
req(iso_data)
iso_data$iso_group <- paste(iso_data$mode, iso_data$time, sep = "_")
pal <- colorRampPalette(brewer.pal(8, "Set2"))
cols <- pal(nrow(iso_data))
for (i in seq_len(nrow(iso_data))) {
poly_i <- iso_data[i, ]
leafletProxy("isoMap") %>%
addPolygons(
data = poly_i,
group = "Isochrones",
color = cols[i],
weight = 2,
fillOpacity = 0.4,
label = paste0(poly_i$mode, " - ", poly_i$time, " mins")
)
}
iso_union <- st_union(iso_data)
iso_union_vect <- vect(iso_union)
ndvi_crop <- terra::crop(ndvi, iso_union_vect)
ndvi_mask <- terra::mask(ndvi_crop, iso_union_vect)
ndvi_vals <- values(ndvi_mask)
ndvi_vals <- ndvi_vals[!is.na(ndvi_vals)]
if (length(ndvi_vals) > 0) {
ndvi_pal <- colorNumeric("YlGn", domain = range(ndvi_vals, na.rm = TRUE), na.color = "transparent")
leafletProxy("isoMap") %>%
addRasterImage(
x = ndvi_mask,
colors = ndvi_pal,
opacity = 0.7,
project = TRUE,
group = "NDVI Raster"
) %>%
addLegend(
position = "bottomright",
pal = ndvi_pal,
values = ndvi_vals,
title = "NDVI"
)
}
# Ensure other layers remain
leafletProxy("isoMap") %>%
addLayersControl(
baseGroups = c("Street Map (Default)", "Satellite (ESRI)", "CartoDB.Positron"),
overlayGroups = c("Income", "Greenspace",
"Hotspots (KnowBR)", "Coldspots (KnowBR)",
"Species Richness", "Data Availability",
"Isochrones", "NDVI Raster"),
options = layersControlOptions(collapsed = FALSE)
)
})
# ------------------------------------------------
# socio_data Reactive + Summaries
# ------------------------------------------------
socio_data <- reactive({
iso_data <- isochrones_data()
if (is.null(iso_data) || nrow(iso_data) == 0) {
return(data.frame())
}
acs_wide <- cbg_vect_sf %>%
mutate(
population = popE,
med_income = medincE
)
hotspot_union  <- st_union(biodiv_hotspots)
coldspot_union <- st_union(biodiv_coldspots)
results <- data.frame()
# Calculate distance to coldspot and hotspots
for (i in seq_len(nrow(iso_data))) {
poly_i <- iso_data[i, ]
dist_hot  <- st_distance(poly_i, hotspot_union)
dist_cold <- st_distance(poly_i, coldspot_union)
dist_hot_km  <- round(as.numeric(min(dist_hot))  / 1000, 3)
dist_cold_km <- round(as.numeric(min(dist_cold)) / 1000, 3)
inter_acs <- st_intersection(acs_wide, poly_i)
vect_acs_wide <- vect(acs_wide)
vect_poly_i <- vect(poly_i)
inter_acs <- intersect(vect_acs_wide, vect_poly_i)
inter_acs = st_as_sf(inter_acs)
pop_total <- 0
inc_str   <- "N/A"
if (nrow(inter_acs) > 0) {
inter_acs$area <- st_area(inter_acs)
inter_acs$area_num <- as.numeric(inter_acs$area)
inter_acs$area_ratio <- inter_acs$area_num / as.numeric(st_area(inter_acs))
inter_acs$weighted_pop <- inter_acs$population * inter_acs$area_ratio
pop_total <- round(sum(inter_acs$weighted_pop, na.rm = TRUE))
w_income <- sum(inter_acs$med_income * inter_acs$area_num, na.rm = TRUE) /
sum(inter_acs$area_num, na.rm = TRUE)
if (!is.na(w_income) && w_income > 0) {
inc_str <- paste0("$", formatC(round(w_income, 2), format = "f", big.mark = ","))
}
}
# Intersection with greenspace
vec_osm_greenspace <- vect(osm_greenspace)
inter_gs <- intersect(vec_osm_greenspace, vect_poly_i)
inter_gs = st_as_sf(inter_gs)
gs_area_m2 <- 0
if (nrow(inter_gs) > 0) {
gs_area_m2 <- sum(st_area(inter_gs))
}
iso_area_m2 <- as.numeric(st_area(poly_i))
gs_area_m2 <- as.numeric(gs_area_m2)
gs_percent <- ifelse(iso_area_m2 > 0, 100 * gs_area_m2 / iso_area_m2, 0)
# NDVI Calculation
poly_vect <- vect(poly_i)
ndvi_crop <- terra::crop(ndvi, poly_vect)
ndvi_mask <- terra::mask(ndvi_crop, poly_vect)
ndvi_vals <- values(ndvi_mask)
ndvi_vals <- ndvi_vals[!is.na(ndvi_vals)]
mean_ndvi <- ifelse(length(ndvi_vals) > 0, round(mean(ndvi_vals, na.rm=TRUE), 3), NA)
# Intersection with GBIF data
inter_gbif <- intersect(vect_gbif, vect_poly_i)
inter_gbif <- st_as_sf(inter_gbif)
inter_gbif_acs <- sf_gbif %>%
mutate(
income = medincE,
ndvi = ndvi_sentinel
)
if (nrow(inter_gbif) > 0) {
inter_gbif_acs <- inter_gbif_acs[inter_gbif_acs$GEOID %in% inter_gbif$GEOID, ]
}
n_records   <- nrow(inter_gbif)
n_species   <- length(unique(inter_gbif$species))
n_birds   <- length(unique(inter_gbif$species[inter_gbif$class == "Aves"]))
n_mammals <- length(unique(inter_gbif$species[inter_gbif$class == "Mammalia"]))
n_plants  <- length(unique(inter_gbif$species[inter_gbif$class %in%
c("Magnoliopsida","Liliopsida","Pinopsida","Polypodiopsida",
"Equisetopsida","Bryopsida","Marchantiopsida") ]))
iso_area_km2 <- round(iso_area_m2 / 1e6, 3)
row_i <- data.frame(
Mode                = tools::toTitleCase(poly_i$mode),
Time                = poly_i$time,
IsochroneArea_km2   = iso_area_km2,
DistToHotspot_km    = dist_hot_km,
DistToColdspot_km   = dist_cold_km,
EstimatedPopulation = pop_total,
MedianIncome        = inc_str,
MeanNDVI            = ifelse(!is.na(mean_ndvi), mean_ndvi, "N/A"),
GBIF_Records        = n_records,
GBIF_Species        = n_species,
Bird_Species        = n_birds,
Mammal_Species      = n_mammals,
Plant_Species       = n_plants,
Greenspace_m2       = round(gs_area_m2, 2),
Greenspace_percent  = round(gs_percent, 2),
stringsAsFactors    = FALSE
)
results <- rbind(results, row_i)
}
iso_union <- st_union(iso_data)
vect_iso <- vect(iso_union)
inter_all_gbif <- intersect(vect_gbif, vect_iso)
inter_all_gbif <- st_as_sf(inter_all_gbif)
union_n_species <- length(unique(inter_all_gbif$species))
rank_percentile <- round(100 * ecdf(cbg_vect_sf$unique_species)(union_n_species), 1)
attr(results, "bio_percentile") <- rank_percentile
# Closest Greenspace from ANY part of the isochrone
dist_mat <- st_distance(iso_union, osm_greenspace)  # 1 x N matrix
if (length(dist_mat) > 0) {
min_dist <- min(dist_mat)
min_idx  <- which.min(dist_mat)
gs_name  <- osm_greenspace$name[min_idx]
attr(results, "closest_greenspace") <- gs_name
} else {
attr(results, "closest_greenspace") <- "None"
}
results
})
# ------------------------------------------------
# Render main summary table
# ------------------------------------------------
output$dataTable <- renderDT({
df <- socio_data()
if (nrow(df) == 0) {
return(DT::datatable(data.frame("Message" = "No isochrones generated yet.")))
}
DT::datatable(
df,
colnames = c(
"Mode"                 = "Mode",
"Time (min)"           = "Time",
"Area (km²)"           = "IsochroneArea_km2",
"Dist. Hotspot (km)"   = "DistToHotspot_km",
"Dist. Coldspot (km)"  = "DistToColdspot_km",
"Population"           = "EstimatedPopulation",
"Median Income"        = "MedianIncome",
"Mean NDVI"            = "MeanNDVI",
"GBIF Records"         = "GBIF_Records",
"Unique Species"       = "GBIF_Species",
"Bird Species"         = "Bird_Species",
"Mammal Species"       = "Mammal_Species",
"Plant Species"        = "Plant_Species",
# "Greenspace (m²)"      = "Greenspace_m2",
"Greenspace (%)"       = "Greenspace_percent"
),
options = list(pageLength = 10, autoWidth = TRUE),
rownames = FALSE
)
})
# ------------------------------------------------
# Biodiversity Access Score + Closest Greenspace
# ------------------------------------------------
output$bioScoreBox <- renderUI({
df <- socio_data()
if (nrow(df) == 0) return(NULL)
percentile <- attr(df, "bio_percentile")
if (is.null(percentile)) percentile <- "N/A"
else percentile <- paste0(percentile, "th Percentile")
wellPanel(
HTML(paste0("<h2>Biodiversity Access Score: ", percentile, "</h2>"))
)
})
output$closestGreenspaceUI <- renderUI({
df <- socio_data()
if (nrow(df) == 0) return(NULL)
gs_name <- attr(df, "closest_greenspace")
if (is.null(gs_name)) gs_name <- "None"
tagList(
strong("Closest Greenspace (from any part of the Isochrone):"),
p(gs_name)
)
})
# ------------------------------------------------
# Secondary table: user-selected CLASS & FAMILY
# ------------------------------------------------
output$classTable <- renderDT({
iso_data <- isochrones_data()
if (is.null(iso_data) || nrow(iso_data) == 0) {
return(DT::datatable(data.frame("Message" = "No isochrones generated yet.")))
}
iso_union <- st_union(iso_data)
vect_iso <- vect(iso_union)
inter_gbif <- intersect(vect_gbif, vect_iso)
inter_gbif = st_as_sf(inter_gbif)
inter_gbif_acs = sf_gbif %>%
mutate(
income = medincE,
ndvi = ndvi_sentinel
)
if (input$class_filter != "All") {
inter_gbif_acs <- inter_gbif_acs[ inter_gbif_acs$class == input$class_filter, ]
}
if (input$family_filter != "All") {
inter_gbif_acs <- inter_gbif_acs[ inter_gbif_acs$family == input$family_filter, ]
}
if (nrow(inter_gbif_acs) == 0) {
return(DT::datatable(data.frame("Message" = "No records for that combination in the isochrone.")))
}
species_counts <- inter_gbif_acs %>%
st_drop_geometry() %>%
group_by(species) %>%
summarize(
n_records   = n(),
mean_income = round(mean(income, na.rm=TRUE), 2),
mean_ndvi   = round(mean(ndvi, na.rm=TRUE), 3),
.groups = "drop"
) %>%
arrange(desc(n_records))
DT::datatable(
species_counts,
colnames = c("Species", "Number of Records", "Mean Income", "Mean NDVI"),
options = list(pageLength = 10),
rownames = FALSE
)
})
# ------------------------------------------------
# Ggplot: Biodiversity & Socioeconomic Summary
# ------------------------------------------------
output$bioSocPlot <- renderPlot({
df <- socio_data()
if (nrow(df) == 0) return(NULL)
df_plot <- df %>%
mutate(IsoLabel = paste0(Mode, "-", Time, "min"))
ggplot(df_plot, aes(x = IsoLabel)) +
geom_col(aes(y = GBIF_Species), fill = "steelblue", alpha = 0.7) +
geom_line(aes(y = EstimatedPopulation / 1000, group = 1), color = "red", size = 1) +
geom_point(aes(y = EstimatedPopulation / 1000), color = "red", size = 3) +
labs(
x = "Isochrone (Mode-Time)",
y = "Unique Species (Blue) | Population (Red) (Thousands)",
title = "Biodiversity & Socioeconomic Summary"
) +
theme_minimal(base_size = 14) +
theme(
axis.text.x  = element_text(angle = 45, hjust = 1, size = 12),
axis.text.y  = element_text(size = 12),
axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14),
plot.title   = element_text(hjust = 0.5, size = 16, face = "bold")
)
})
# ------------------------------------------------
# Bar plot: GBIF records by institutionCode
# ------------------------------------------------
output$collectionPlot <- renderPlot({
iso_data <- isochrones_data()
if (is.null(iso_data) || nrow(iso_data) == 0) {
plot.new()
title("No GBIF records found in this isochrone.")
return(NULL)
}
iso_union <- st_union(iso_data)
vect_iso <- vect(iso_union)
inter_gbif <- intersect(vect_gbif, vect_iso)
inter_gbif = st_as_sf(inter_gbif)
if (nrow(inter_gbif) == 0) {
plot.new()
title("No GBIF records found in this isochrone.")
return(NULL)
}
df_code <- inter_gbif %>%
st_drop_geometry() %>%
group_by(institutionCode) %>%
summarize(count = n(), .groups = "drop") %>%
arrange(desc(count)) %>%
mutate(truncatedCode = substr(institutionCode, 1, 5)) # Shorter version of the names
ggplot(df_code, aes(x = reorder(truncatedCode, -count), y = count)) +
geom_bar(stat = "identity", fill = "darkorange", alpha = 0.7) +
labs(
x = "Institution Code (Truncated)",
y = "Number of Records",
title = "GBIF Records by Institution Code (Isochrone Union)"
) +
theme_minimal(base_size = 14) +
theme(
axis.text.x  = element_text(angle = 45, hjust = 1, size = 12),
axis.text.y  = element_text(size = 12),
axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14),
plot.title   = element_text(hjust = 0.5, size = 16, face = "bold")
)
})
# ------------------------------------------------
# Additional Plot: n_observations vs n_species
# ------------------------------------------------
# Make it reactive: obsVsSpeciesPlot updates dynamically based on user-selected class_filter or family_filter.
filtered_data <- reactive({
data <- cbg_vect_sf
if (input$class_filter != "All") {
data <- data[data$class == input$class_filter, ]
}
if (input$family_filter != "All") {
data <- data[data$family == input$family_filter, ]
}
data
})
output$obsVsSpeciesPlot <- renderPlot({
data <- filtered_data()
if (nrow(data) == 0) {
plot.new()
title("No data available for selected filters.")
return(NULL)
}
ggplot(data, aes(x = log(n_observations + 1), y = log(unique_species + 1))) +
geom_point(color = "blue", alpha = 0.6) +
labs(
x = "Log(Number of Observations + 1)",
y = "Log(Species Richness + 1)",
title = "Data Availability vs. Species Richness"
) +
theme_minimal(base_size = 14) +
theme(
axis.text.x  = element_text(size = 12),
axis.text.y  = element_text(size = 12),
axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14),
plot.title   = element_text(hjust = 0.5, size = 16, face = "bold")
)
})
# ------------------------------------------------
# [Optional: Linear Model Plot (Commented Out)]
# ------------------------------------------------
# Uncomment and adjust if needed
# output$lmCoefficientsPlot <- renderPlot({
#   df_lm <- cbg_vect_sf %>%
#     filter(!is.na(n_observations),
#            !is.na(unique_species),
#            !is.na(median_inc),
#            !is.na(ndvi_mean))
#
#   if (nrow(df_lm) < 5) {
#     plot.new()
#     title("Not enough data for linear model.")
#     return(NULL)
#   }
#
#   fit <- lm(unique_species ~ n_observations + median_inc + ndvi_mean, data = df_lm)
#
#   p <- plot_model(fit, show.values = TRUE, value.offset = .3, title = "LM Coefficients: n_species ~ n_observations + median_inc + ndvi_mean")
#   print(p)
# })
#
# # Add Images:
# df_img = data.frame(id = c(1:3), img_path=c('California_academy_logo.png', 'Reimagining_San_Francisco.png', 'UC Berkeley_logo.png'))
# n <- nrow(df_img)
#
# n <- nrow(df_img)
#
# observe({
#   for (i in 1:n)
#   {
#     print(i)
#     local({
#       my_i <- i
#       imagename = paste0("img", my_i)
#       print(imagename)
#       output[[imagename]] <-
#         renderImage({
#           list(src = file.path('www', df_img$img_path[my_i]),
#                width = "100%", height = "55%",
#                alt = "Image failed to render")
#         }, deleteFile = FALSE)
#     })
#   }
# })
#
#
# output$houz <- renderUI({
#
#   image_output_list <-
#     lapply(1:n,
#            function(i)
#            {
#              imagename = paste0("img", i)
#              imageOutput(imagename)
#            })
#
#   do.call(tagList, image_output_list)
# })
}
# Run the Shiny app
shinyApp(ui, server)
install.packages("rinat")
require(rinat)
nymphalidae <- get_inat_obs(taxon_name  = "Nymphalidae", year = 2015)
nymphalidae
?get_inat_obs
library(tidycensus)
library(sf)
library(dplyr)
library(rinat)
counties_list <- c(
"Los Angeles",
"San Diego",
"San Francisco",
"Marin",
"Sonoma",
"Napa",
"Solano",
"Contra Costa",
"Alameda",
"Santa Clara",
"San Mateo"
)
get_inat_for_county <- function(county_name) {
# Get the geometry for the county via tidycensus
geo <- get_acs(
geography = "county",
variables = "B19013_001",  # any single variable; we just want geometry
state = "CA",
county = county_name,
geometry = TRUE
)
# Extract bounding box from the sf geometry
bb <- st_bbox(geo)
# iNaturalist wants bounding box in the form:
#   c(lat_min, lng_min, lat_max, lng_max)
# st_bbox returns: c(xmin, ymin, xmax, ymax) which is (lon, lat, lon, lat)
# So reorder accordingly:
bounds <- c(bb$ymin, bb$xmin, bb$ymax, bb$xmax)
# Retrieve iNaturalist observations for all taxa,
# capping at 10 million results
inat_data <- get_inat_obs(
bounds     = bounds,
maxresults = 1e7  # 10 million
)
# Optionally, tag the county in the results
inat_data$county_name <- county_name
return(inat_data)
}
LA_iNat <- lapply(counties_list[1], get_inat_for_county)
